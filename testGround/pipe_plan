

PLAN TO MAKE PIPES

create Input type:

typedef struct {
    char **strs;
    char *command;
    char **args;

    char *redirectSymbol;
    char *writeFile;
    bool isRedirect;

    bool isPipe; //is pipe flag
    
} Input;


//redirect stdout to write file *CHANGED TO ACCOUNT FOR PIPES
void configure_redirection(char *redirectSymbol, char *writeFile) {
    //file descriptor
    int fd;

    //check redirect types and set correct mode
    if(strcmp(redirectSymbol, ">>") == 0) {
        fd = open(writeFile, O_WRONLY | O_APPEND | O_CREAT, 0644);
    }

    else if(strcmp(redirectSymbol, ">") == 0) {
        fd = open(writeFile, O_WRONLY | O_TRUNC | O_CREAT, 0644);
    }

    //error handling
    if(dup2(fd, STDOUT_FILENO) == -1) {
        printf("dup2 failed");
    }

    close(fd);
}



Input process_input(char* inputStr) {

        char *token = strtok(inputStr, " ");

    //define input type for holding input values (terrible name)
    Input vals;

    //allocate for input members
    vals.strs = malloc(MAX_STRINGS * sizeof(char *));
    vals.command = malloc(MAX_CMD_LEN * sizeof(char *));
    vals.args = malloc(MAX_STRINGS * sizeof(char *));
    vals.isRedirect = false;

    //copy individual inputs into an array of strings
    int i = 0;
        while(token != NULL && i < MAX_STRINGS) {

            vals.strs[i] = malloc(strlen(token) + 1);
            if (vals.strs[i] == NULL) {
                perror("failed to allocate memory");
                exit(1);
            }

            if vals.strs[i] == "|":
            isPipe = true
            char* temp;
            temp = inputStr;
            inputStr = temp[i];
            strncpy(inputStr, temp + i, strlen(temp) - i);
            free(temp);
            break;

            strcpy(vals.strs[i], token);

            token = strtok(NULL, " ");
            i += 1;
        }

        //set null terminator
        vals.strs[i] = NULL;

        //check if there is a command or if it exists then copy into input member
        if(vals.strs[0] != NULL && check_cmd(vals.strs[0])) {
            strcpy(vals.command, vals.strs[0]);
        }

        else {
            printf("%c%s%c%s", '"', vals.strs[0], '"' ," is an unknown or missing command");
        }

        if(vals.strs[1] != NULL) {
        //S int num_args = (sizeof(vals.strs) / sizeof(vals.strs[1])) - 1;

     //handle rest of the inputs (redirect symbols/args)
        for(int j = 1; vals.strs[j] != NULL; j++) {
            
                  // ******************************* PLAN TO ADD PIPES *****************************************

            //handle redirection (configure redirect type and write file)
            if((vals.strs[j][0] == '>' || vals.strs[j][0] == '<') || vals.isRedirect) {

                if(vals.isRedirect) {
                    //TODO: handle missing file
                    vals.writeFile = malloc(strlen(vals.strs[j]));
                    strcpy(vals.writeFile, vals.strs[j]);
                    continue;
                }
                vals.redirectSymbol = malloc(strlen(vals.strs[j]));
                strcpy(vals.redirectSymbol, vals.strs[j]);
                vals.isRedirect = true;

            }

            //else add to args
            else {
                vals.args[j-1] = malloc(strlen(vals.strs[j]) + 1);
                strcpy(vals.args[j-1], vals.strs[j]);
            }
        }
    }





// **************************** main() LINE 157 ****************************************
        //loop for terminal
    while(1==1) {
        printf("\nEnter a command or type 'escape' to exit $ ");

        //get user input
        fgets(inputStr, sizeof(inputStr), stdin);

        //set ending newline to null terminator
        inputStr[strcspn(inputStr, "\n")] = '\0';

        Input results = process_input(inputStr);

        // *********** FOR PIPES **********

        if results.isPipe:
            //list of inputs to execute and flag saying we need to read in more pipes
            Input *input_pipes[50] //<- arbitrary size for now
            bool more_pipes = true
            char ** input_stirngs

            int i = 0
            while more_pipes:
                //* will need to extract input strings between pipes
                input_pipes[i] = process_input(input_strings[i])
                more_pipes = input_pipes[i].isPipe


            // EXECUTE THE COMMANDS
            int j = 0
            while input_pipes[j] != NULL:
                
                pid = fork

                if childProcess:
                    run_commands(cmd args) // set file descriptor


        //If not a local command, run create child and run external
        bool local = run_local_commands(results.command, results.args);
        if(!local) {
            
            pid_t pid = fork();

            //if fork failed
            if(pid == -1) {
                printf("failed to fork");
                exit(1);